{"version":3,"file":"coding.js","names":["_variant","require","_nodeid","_localized_text","_opcua_status_code","_qualified_name","_datavalue","_expanded_nodeid","_diagnostic_info","_Object","asIs","b","mapPropertyAs","map","obj","key","dataType","Object","assign","toRawValue","DataType","Null","StatusCode","name","QualifiedName","namespaceIndex","LocalizedText","text","locale","DataValue","value","options","pick","Variant","arrayType","dimensions","getRawValue","DiagnosticInfo","info","VariantArrayType","Scalar","Array","isArray","from","val","encodeVariant","Buffer","rawValue","stringify","a","toJSON","JSON","stringified","toString","trim","decodeAsString","decodeAsInt","parseInt","decodeAsFloat","parseFloat","decodeAsJson","parse","decodeRawValue","Boolean","SByte","Byte","Int16","UInt16","Int32","UInt32","Int64","UInt64","Float","Double","String","DateTime","Guid","XmlElement","NodeId","ExpandedNodeId","toNodeValue","s","Date","ByteString","data","resolveNodeId","nodeId","defs","split","identifierType","namespace","namespaceUri","serverIndex","reduce","opts","def","match","slice","StatusCodes","getNodeValue","Error","raw","decodeVariant","buffer","length"],"sources":["../../src/lib/coding.js"],"sourcesContent":["import { DataType, VariantArrayType, Variant } from 'node-opcua/lib/datamodel/variant';\r\nimport { resolveNodeId } from 'node-opcua/lib/datamodel/nodeid';\r\nimport { LocalizedText } from 'node-opcua/lib/datamodel/localized_text';\r\nimport { StatusCodes } from 'node-opcua/lib/datamodel/opcua_status_code';\r\nimport { QualifiedName } from 'node-opcua/lib/datamodel/qualified_name';\r\nimport { DataValue } from 'node-opcua/lib/datamodel/datavalue';\r\nimport { ExpandedNodeId } from 'node-opcua/lib/datamodel/expanded_nodeid';\r\nimport { DiagnosticInfo } from 'node-opcua/lib/datamodel/diagnostic_info';\r\nimport { pick } from './helpers/Object';\r\n\r\n/**\r\n * Function that returns the passed argument as is.\r\n * @param {*} b The input argument.\r\n * @return {*} The value passed.\r\n */\r\nconst asIs = (b) => b;\r\n\r\n/**\r\n * Maps a single property of an object using the the mapper defined in *map* for the given\r\n * *dataType*.\r\n * @param {Map<node-opcua~DataType, function} map The mappings to use.\r\n * @param {Object} obj The object to process.\r\n * @param {string} key Name of the property to map.\r\n * @param {node-opcua~DataType} dataType The data type to map the property to.\r\n */\r\nconst mapPropertyAs = (map, obj, key, dataType) => {\r\n  if (obj[key]) {\r\n    return Object.assign(obj, {\r\n      [key]: map[dataType](obj[key]),\r\n    });\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\n/**\r\n * A set of functions that return raw values from {@link node-opcua~Variant} for specific\r\n * {@link node-opcua~DataType}s.\r\n * @type {Map<node-opcua~DataType, function(value: any): any>}\r\n */\r\nconst toRawValue = {\r\n  [DataType.Null]: () => null,\r\n  [DataType.StatusCode]: ({ name }) => name,\r\n  [DataType.QualifiedName]: ({ namespaceIndex, name }) => ({ namespaceIndex, name }),\r\n  [DataType.LocalizedText]: ({ text, locale }) => ({ text: text || null, locale }),\r\n  [DataType.DataValue]: (value) => {\r\n    const options = pick(value, [\r\n      'value',\r\n      'statusCode',\r\n      'sourceTimestamp',\r\n      'sourcePicoseconds',\r\n      'serverTimestamp',\r\n      'serverPicoseconds',\r\n    ]);\r\n\r\n    mapPropertyAs(toRawValue, options, 'value', DataType.Variant);\r\n    mapPropertyAs(toRawValue, options, 'statusCode', DataType.StatusCode);\r\n    // NOTE: server- and sourceTimstamps get mapped as dates\r\n\r\n    return options;\r\n  },\r\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) => ({\r\n    dataType,\r\n    arrayType,\r\n    // eslint-disable-next-line no-use-before-define\r\n    value: getRawValue({ value, dataType, arrayType }),\r\n    dimensions,\r\n  }),\r\n  [DataType.DiagnosticInfo]: (info) => {\r\n    const options = pick(info, [\r\n      'namespaceUri',\r\n      'symbolicId',\r\n      'locale',\r\n      'localizedText',\r\n      'additionalInfo',\r\n      'innerStatusCode',\r\n      'innerDiagnosticInfo',\r\n    ]);\r\n\r\n    mapPropertyAs(toRawValue, options, 'innerStatusCode', DataType.StatusCode);\r\n    mapPropertyAs(toRawValue, options, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\r\n\r\n    return options;\r\n  },\r\n};\r\n\r\n/**\r\n * Returns the raw value for a {@link node-opcua~Variant}.\r\n * @param {node-opcua~Variant} variant The variant to convert.\r\n */\r\nfunction getRawValue({ value, dataType, arrayType }) {\r\n  if (arrayType !== VariantArrayType.Scalar) {\r\n    return (Array.isArray(value) ? value : Array.from(value)).map((val) =>\r\n      getRawValue({\r\n        value: val,\r\n        dataType,\r\n        arrayType: VariantArrayType[arrayType.value - 1],\r\n      })\r\n    );\r\n  }\r\n\r\n  return (toRawValue[dataType] || asIs)(value);\r\n}\r\n\r\n/**\r\n * Returns a buffer containing a {@link node-opcua~Variant}s encoded value.\r\n * @param {node-opcua~Variant} variant The variant to encode.\r\n * @return {Buffer} A buffer containing the encoded value.\r\n */\r\nexport function encodeVariant({ value, dataType, arrayType }) {\r\n  if (value === null) {\r\n    return Buffer.from([]);\r\n  }\r\n\r\n  const rawValue = getRawValue({ value, dataType, arrayType });\r\n\r\n  if (rawValue instanceof Buffer) {\r\n    return rawValue;\r\n  }\r\n\r\n  const stringify = (a) => (a.toJSON ? a.toJSON() : JSON.stringify(a, null, '  '));\r\n\r\n  const stringified =\r\n    typeof rawValue === 'object' ? stringify(rawValue) : rawValue.toString().trim();\r\n\r\n  return Buffer.from(stringified);\r\n}\r\n\r\n/**\r\n * Decodes a buffer to a string.\r\n * @param {Buffer} b The buffer to decode from.\r\n * @return {string} The buffer's string representation.\r\n */\r\nconst decodeAsString = (b) => b.toString().trim();\r\n\r\n/**\r\n * Decodes a buffer to an integer value.\r\n * @param {Buffer} b The buffer to decode from.\r\n * @return {number} The decoded integer.\r\n */\r\nconst decodeAsInt = (b) => parseInt(decodeAsString(b), 10);\r\n\r\n/**\r\n * Decodes a buffer to a float value.\r\n * @param {Buffer} b The buffer to decode from.\r\n * @return {number} The decoded float.\r\n */\r\nconst decodeAsFloat = (b) => parseFloat(decodeAsString(b));\r\n\r\n/**\r\n * Decodes a buffer using JSON.\r\n * @param {Buffer} b The buffer to decode from.\r\n * @return {*} The decoded value, most likely an Object.\r\n */\r\nconst decodeAsJson = (b) => JSON.parse(b.toString());\r\n\r\n/**\r\n * Mapping functions that return raw values for a stored value of the given type.\r\n * @type {Map<node-opcua~DataType, function>}\r\n */\r\nconst decodeRawValue = {\r\n  [DataType.Null]: () => null,\r\n  [DataType.Boolean]: (b) => decodeAsString(b) === 'true',\r\n  [DataType.SByte]: decodeAsInt,\r\n  [DataType.Byte]: decodeAsInt,\r\n  [DataType.Int16]: decodeAsInt,\r\n  [DataType.UInt16]: decodeAsInt,\r\n  [DataType.Int32]: decodeAsInt,\r\n  [DataType.UInt32]: decodeAsInt,\r\n  [DataType.Int64]: decodeAsJson,\r\n  [DataType.UInt64]: decodeAsJson,\r\n  [DataType.Float]: decodeAsFloat,\r\n  [DataType.Double]: decodeAsFloat,\r\n  [DataType.String]: decodeAsString,\r\n  [DataType.DateTime]: decodeAsString,\r\n  [DataType.Guid]: decodeAsString,\r\n  // ByteString maps to Buffer\r\n  [DataType.XmlElement]: decodeAsString,\r\n  [DataType.NodeId]: decodeAsString,\r\n  [DataType.ExpandedNodeId]: decodeAsString,\r\n  [DataType.StatusCode]: decodeAsString,\r\n  [DataType.QualifiedName]: decodeAsJson,\r\n  [DataType.LocalizedText]: decodeAsJson,\r\n  // FIXME: Add ExtensionObject\r\n  [DataType.DataValue]: decodeAsJson,\r\n  [DataType.Variant]: decodeAsJson,\r\n  [DataType.DiagnosticInfo]: decodeAsJson,\r\n};\r\n\r\n/**\r\n * Mapping functions that return OPC-UA node values for raw values.\r\n * @type {Map<node-opcua~DataType, function>}\r\n */\r\nconst toNodeValue = {\r\n  [DataType.DateTime]: (s) => new Date(s),\r\n  [DataType.ByteString]: (b) => {\r\n    if (b instanceof Buffer) {\r\n      return b;\r\n    }\r\n\r\n    return Buffer.from(b.data, 'binary');\r\n  },\r\n  [DataType.NodeId]: (s) => resolveNodeId(s),\r\n\r\n  // Jep, node-opcua does not provide a resolve function for expanded nodeids\r\n  [DataType.ExpandedNodeId]: (s) => {\r\n    const nodeId = resolveNodeId(s);\r\n    const [value, ...defs] = nodeId.value.split(';');\r\n\r\n    const { identifierType, namespace, namespaceUri, serverIndex } = defs.reduce((opts, def) => {\r\n      const match = def.match(/^([^:]+):(.*)/);\r\n      if (!match) {\r\n        return opts;\r\n      }\r\n\r\n      let [key, val] = match.slice(1); // eslint-disable-line prefer-const\r\n\r\n      if (key === 'serverIndex') {\r\n        val = parseInt(val, 10);\r\n      }\r\n\r\n      return Object.assign(opts, { [key]: val });\r\n    }, Object.assign({}, nodeId));\r\n\r\n    return new ExpandedNodeId(identifierType, value, namespace, namespaceUri, serverIndex);\r\n  },\r\n\r\n  [DataType.StatusCode]: (name) => StatusCodes[name],\r\n  [DataType.QualifiedName]: (options) => new QualifiedName(options),\r\n  [DataType.LocalizedText]: (options) => new LocalizedText(options),\r\n  [DataType.DataValue]: (options) => {\r\n    const opts = options;\r\n\r\n    mapPropertyAs(toNodeValue, opts, 'value', DataType.Variant);\r\n    mapPropertyAs(toNodeValue, opts, 'statusCode', DataType.StatusCode);\r\n    mapPropertyAs(toNodeValue, opts, 'sourceTimestamp', DataType.DateTime);\r\n    mapPropertyAs(toNodeValue, opts, 'serverTimestamp', DataType.DateTime);\r\n\r\n    return new DataValue(opts);\r\n  },\r\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) =>\r\n    new Variant({\r\n      dataType,\r\n      arrayType: VariantArrayType[arrayType],\r\n      value,\r\n      dimensions,\r\n    }),\r\n  [DataType.DiagnosticInfo]: (options) => {\r\n    const opts = options;\r\n\r\n    mapPropertyAs(toNodeValue, opts, 'innerStatusCode', DataType.StatusCode);\r\n    mapPropertyAs(toNodeValue, opts, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\r\n\r\n    return new DiagnosticInfo(opts);\r\n  },\r\n};\r\n\r\n/**\r\n * Returns a node's OPC-UA value based on it's raw value and type.\r\n * @param {*} rawValue A node's raw value.\r\n * @param {node-opcua~DataType} dataType A node's data type.\r\n * @param {node-opcua~VariantArrayType} arrayType A node's array type.\r\n */\r\nconst getNodeValue = (rawValue, dataType, arrayType) => {\r\n  if (arrayType.value !== VariantArrayType.Scalar.value) {\r\n    if (!Array.isArray(rawValue)) {\r\n      throw new Error('Value is not an array');\r\n    }\r\n\r\n    return rawValue.map((raw) =>\r\n      getNodeValue(raw, dataType, VariantArrayType[arrayType.value - 1])\r\n    );\r\n  }\r\n\r\n  return (toNodeValue[dataType] || asIs)(rawValue);\r\n};\r\n\r\n/**\r\n * Returns a {@link node-opcua~Variant} from a Buffer with the given *dataType* and *arrayType*.\r\n * @param {Buffer} buffer The buffer to decode from.\r\n * @param {Object} options The options to use.\r\n * @param {node-opcua~DataType} options.dataType The data type to decode to.\r\n * @param {node-opcua~VariantArrayType} options.arrayType The array type to decode to.\r\n */\r\nexport function decodeVariant(buffer, { dataType, arrayType }) {\r\n  if (buffer === null || buffer.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  if (dataType === DataType.ByteString && arrayType === VariantArrayType.Scalar) {\r\n    return buffer;\r\n  }\r\n\r\n  const rawValue =\r\n    arrayType === VariantArrayType.Scalar\r\n      ? (decodeRawValue[dataType] || asIs)(buffer)\r\n      : JSON.parse(buffer.toString());\r\n\r\n  return getNodeValue(rawValue, dataType, arrayType);\r\n}\r\n"],"mappings":"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","ignoreList":[]}