{"version":3,"file":"Node.js","names":["_opcua_node_ids","require","_nodeclass","_Object","_mapping","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","ReferenceTypeIds","exports","OpcReferenceTypeIds","toParent","ReferenceTypeNames","reverse","ReferenceMap","Map","addReference","type","nodeId","set","get","add","Set","deleteReference","ref","delete","size","Error","getSingle","Array","from","toJSON","reduce","result","key","assign","Node","constructor","name","parent","nodeClass","fileName","idName","_unresolved","parentResolvesMetadata","_parentResolvesMetadata","markAsResolved","_resolved","isResolved","has","id","references","_unresolvedReferences","setReferences","ids","markReferenceAsResolved","_resolvedReferences","markAllReferencesAsResolved","hasUnresolvedReference","_filePath","concat","filePath","_nodeId","specialId","separator","match","typeDefinition","HasTypeDefinition","modellingRule","HasModellingRule","hasTypeDefinition","typeDefName","def","hasUnresolvedMetadata","metadata","meta","isVariableNode","dataType","arrayType","sortReferences","createChild","extension","node","isVariable","NodeClass","Variable","isDisplay","isScript","isQuickDynamic","isDisplayScript","default","ServerNode","renameTo","SourceNode"],"sources":["../../../src/lib/model/Node.ts"],"sourcesContent":["import { ReferenceTypeIds as OpcReferenceTypeIds } from 'node-opcua/lib/opcua_node_ids';\r\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\r\nimport { VariantArrayType, DataType, Variant } from 'node-opcua/lib/datamodel/variant';\r\nimport { ItemOf, KeyOf } from 'node-opcua/lib/misc/enum.js';\r\nimport { reverse } from '../helpers/Object';\r\nimport { sortReferences } from '../helpers/mapping';\r\nimport { ValueOf } from '../helpers/types';\r\n\r\n/**\r\n * References type ids.\r\n */\r\nexport const ReferenceTypeIds = {\r\n  ...OpcReferenceTypeIds,\r\n  toParent: -1,\r\n};\r\n\r\n/** A reference type name */\r\ntype ReferenceTypeName = keyof typeof ReferenceTypeIds;\r\n\r\n/** A raw (number) reference type */\r\ntype ReferenceType = ValueOf<typeof ReferenceTypeIds>;\r\n\r\n/** Node references stored in definition files */\r\nexport type ReferenceDefinitions = {\r\n  [type in ReferenceTypeName]?: (number | string)[];\r\n};\r\n\r\n/** Node definition stored in definition file */\r\nexport interface NodeDefinition {\r\n  nodeId?: string;\r\n  nodeClass?: KeyOf<typeof NodeClass>; // Defaults to 'Variable'\r\n  dataType?: KeyOf<typeof DataType>;\r\n  arrayType?: KeyOf<typeof VariantArrayType>;\r\n  references?: ReferenceDefinitions;\r\n}\r\n\r\n/**\r\n * Names for references.\r\n */\r\nexport const ReferenceTypeNames = reverse(ReferenceTypeIds) as { [key: number]: string };\r\n\r\n/**\r\n * A map specialized for holding references.\r\n */\r\nclass ReferenceMap extends Map<ReferenceType, Set<number | string>> {\r\n  /**\r\n   * Adds a new reference.\r\n   * @param {number} type The reference id.\r\n   * @param {string} nodeId The reference target node's id.\r\n   */\r\n  public addReference(type: ReferenceType, nodeId: number | string): void {\r\n    const set = this.get(type);\r\n    if (set) {\r\n      set.add(nodeId);\r\n    } else {\r\n      this.set(type, new Set([nodeId]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes the given reference.\r\n   * @param {number} type The reference id.\r\n   * @param {string} nodeId The reference target node's id.\r\n   */\r\n  public deleteReference(type: ReferenceType, nodeId: number | string): number | string {\r\n    const set = this.get(type);\r\n    if (set) {\r\n      const ref = set.delete(nodeId);\r\n\r\n      if (ref) {\r\n        if (set.size === 0) {\r\n          this.delete(type);\r\n        }\r\n\r\n        return nodeId;\r\n      }\r\n    }\r\n\r\n    throw new Error(`No ${ReferenceTypeNames[type] || type} reference to ${nodeId}`);\r\n  }\r\n\r\n  /**\r\n   * Returns the first entry of a specific type.\r\n   * @param type The reference type id to look for.\r\n   * @return The first reference found or undefined.\r\n   */\r\n  public getSingle(type: ReferenceType): number | string | undefined {\r\n    const set = this.get(type);\r\n    return set && Array.from(set)[0];\r\n  }\r\n\r\n  /**\r\n   * Returns a plain object of refernces.\r\n   * @return A string describing the reference map.\r\n   */\r\n  public toJSON(): ReferenceDefinitions {\r\n    return [...this].reduce(\r\n      (result, [key, value]) =>\r\n        Object.assign(result, {\r\n          [ReferenceTypeNames[key] || key]: [...value],\r\n        }),\r\n      {}\r\n    );\r\n  }\r\n}\r\n\r\ninterface WithValue {\r\n  value: Variant;\r\n}\r\n\r\nexport interface NodeOptions {\r\n  name: string;\r\n  parent?: Node;\r\n  nodeClass: ItemOf<typeof NodeClass>;\r\n}\r\n\r\ntype NodeResolveKey = 'nodeClass' | 'dataType' | 'arrayType';\r\n\r\n/**\r\n * The main model class.\r\n */\r\nexport default abstract class Node {\r\n  /** The node's name when stored to a file. */\r\n  protected fileName: string;\r\n  /** The node's name when written to the server. */\r\n  protected idName: string;\r\n  /** The id stored in the definition file. */\r\n  protected specialId?: string;\r\n\r\n  /** The node's parent node. */\r\n  public readonly parent?: Node;\r\n  /** The node's class. */\r\n  public readonly nodeClass: ItemOf<typeof NodeClass>;\r\n\r\n  /** A set of resolved properties. */\r\n  protected _resolved = new Set<NodeResolveKey>();\r\n  /** A set of unresolved properties. */\r\n  protected _unresolved: Set<NodeResolveKey>;\r\n  /** The node's references. */\r\n  public references = new ReferenceMap();\r\n  /** The node's unresolved refernces. */\r\n  protected _resolvedReferences = new ReferenceMap();\r\n  /** The node's resolved refernces. */\r\n  protected _unresolvedReferences = new ReferenceMap();\r\n  /** If the parent node resolves metadata. */\r\n  protected _parentResolvesMetadata = false;\r\n\r\n  /**\r\n   * Creates a new node.\r\n   * @param {Object} options The options to use.\r\n   * @param {string} options.name The node's name.\r\n   * @param {Node} options.parent The node's parent node.\r\n   * @param {node-opcua~NodeClass} options.nodeClass The node's class.\r\n   */\r\n  public constructor({ name, parent, nodeClass /* , referenceToParent */ }: NodeOptions) {\r\n    this.fileName = name;\r\n    this.idName = name;\r\n    this.parent = parent;\r\n    this.nodeClass = nodeClass;\r\n\r\n    this._unresolved = new Set([\r\n      'nodeClass',\r\n      // Only for variables\r\n      'dataType',\r\n      'arrayType',\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * If the parent resolves metadata (for example: split transformer source files).\r\n   */\r\n  public get parentResolvesMetadata(): boolean {\r\n    return this._parentResolvesMetadata;\r\n  }\r\n\r\n  public markAsResolved(key: NodeResolveKey): void {\r\n    const value = this._unresolved.delete(key);\r\n\r\n    // FIXME: Only test if debug / test\r\n    if (value === false) {\r\n      throw new Error(`'${key}' is already resolved`);\r\n    }\r\n\r\n    this._resolved.add(key);\r\n  }\r\n\r\n  public isResolved(key: NodeResolveKey): boolean {\r\n    return this._resolved.has(key);\r\n  }\r\n\r\n  /**\r\n   * Adds a new reference.\r\n   * @param {number} type The reference type's id.\r\n   * @param {string} id The reference target node's id.\r\n   */\r\n  public addReference(type: ReferenceType, id: string): void {\r\n    this.references.addReference(type, id);\r\n    this._unresolvedReferences.addReference(type, id);\r\n  }\r\n\r\n  public setReferences(type: ReferenceType, ids: string[]): void {\r\n    this.references.set(type, new Set(ids));\r\n    this._unresolvedReferences.set(type, new Set(ids));\r\n  }\r\n\r\n  public markReferenceAsResolved(name: ReferenceTypeName, value: string): void {\r\n    const type = ReferenceTypeIds[name];\r\n    const ref = this._unresolvedReferences.deleteReference(type, value);\r\n    this._resolvedReferences.addReference(type, ref);\r\n  }\r\n\r\n  public markAllReferencesAsResolved(name: ReferenceTypeName): void {\r\n    const type = ReferenceTypeIds[name];\r\n    this._unresolvedReferences.delete(type);\r\n  }\r\n\r\n  public hasUnresolvedReference(name: ReferenceTypeName): boolean {\r\n    const type = ReferenceTypeIds[name];\r\n    return this._unresolvedReferences.has(type);\r\n  }\r\n\r\n  /**\r\n   * The node's file path, used to compute {@link Node#filePath}.\r\n   */\r\n  private get _filePath(): string[] {\r\n    if (!this.parent) {\r\n      return [this.fileName];\r\n    }\r\n    return this.parent._filePath.concat(this.fileName);\r\n  }\r\n\r\n  /**\r\n   * The node's file path.\r\n   */\r\n  public get filePath(): string[] {\r\n    if (!this.parent) {\r\n      return [];\r\n    }\r\n    return this.parent._filePath;\r\n  }\r\n\r\n  /**\r\n   * The node's id, used to compute {@link Node#nodeId}.\r\n   */\r\n  private get _nodeId(): { id: string; separator: '/' | '.' } {\r\n    if (this.specialId) {\r\n      return {\r\n        id: this.specialId,\r\n        separator: this.specialId.match(/\\.RESOURCES\\/?/) ? '/' : '.',\r\n      };\r\n    }\r\n\r\n    if (!this.parent) {\r\n      return {\r\n        id: this.idName,\r\n        separator: '.',\r\n      };\r\n    }\r\n\r\n    const { separator, id } = this.parent._nodeId;\r\n\r\n    if (this._parentResolvesMetadata) {\r\n      return { separator, id };\r\n    }\r\n\r\n    return {\r\n      separator: this.idName === 'RESOURCES' ? '/' : separator,\r\n      id: `${id}${separator}${this.idName}`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * The node's id.\r\n   */\r\n  public get nodeId(): string {\r\n    return this._nodeId.id;\r\n  }\r\n\r\n  /**\r\n   * The node's type definition if given.\r\n   */\r\n  public get typeDefinition(): number | string | undefined {\r\n    return this.references.getSingle(ReferenceTypeIds.HasTypeDefinition);\r\n  }\r\n\r\n  /**\r\n   * The node's modellingRule if given.\r\n   * @type {?number}\r\n   */\r\n  public get modellingRule(): number | string | undefined {\r\n    return this.references.getSingle(ReferenceTypeIds.HasModellingRule);\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the node has the given type definition.\r\n   * @param typeDefName - The type definition to check.\r\n   * @return If the node has the given type definition.\r\n   */\r\n  public hasTypeDefinition(typeDefName: number | string): boolean {\r\n    const def = this.typeDefinition;\r\n\r\n    return def ? def === typeDefName : false;\r\n  }\r\n\r\n  /**\r\n   * `true` at the moment.\r\n   */\r\n  public get hasUnresolvedMetadata(): boolean {\r\n    return true;\r\n    /* FIXME: Once plugin mapping is implemented\r\n    const value = !this._parentResolvesMetadata && (Boolean(this._unresolved.size) ||\r\n      Boolean(this._unresolvedReferences.size) || this.specialId);\r\n\r\n    // FIXME: If debug / test\r\n    if (!value && Object.keys(this.metadata).length > 0) {\r\n      throw new Error(`#hasUnresolvedMetadata did return invalid result ${\r\n        value\r\n      } for ${\r\n        JSON.stringify(Object.assign(this, {parent: undefined, value: undefined }), null, '  ')\r\n      }`);\r\n    } else if (value && Object.keys(this.metadata).length === 0) {\r\n      throw new Error('#metadata did return invalid result');\r\n    }\r\n\r\n    return value; */\r\n  }\r\n\r\n  /**\r\n   * The metadata to store in the node's definition file.\r\n   * @type {Object}\r\n   */\r\n  public get metadata(): NodeDefinition {\r\n    if (this._parentResolvesMetadata) {\r\n      return {};\r\n    }\r\n\r\n    const meta: Partial<NodeDefinition> = {};\r\n\r\n    if (this.specialId) {\r\n      meta.nodeId = this.specialId;\r\n    }\r\n\r\n    if (this.isVariableNode()) {\r\n      meta.dataType = this.value.dataType.key;\r\n      meta.arrayType = this.value.arrayType.key;\r\n    } else {\r\n      meta.nodeClass = this.nodeClass.key;\r\n    }\r\n\r\n    meta.references = sortReferences(this.references.toJSON());\r\n\r\n    /* FIXME: Once plugin mapping is implemented\r\n    for (const unresolved of this._unresolved) {\r\n      let value = this[unresolved];\r\n\r\n      if (unresolved === 'dataType') {\r\n        value = this.value.dataType ? this.value.dataType.key : 'UNKNOWN';\r\n      } else if (unresolved === 'arrayType') {\r\n        value = this.value.arrayType ? this.value.arrayType.key : 'UNKNOWN';\r\n      }\r\n\r\n      meta[unresolved] = value;\r\n    }\r\n\r\n\r\n    if (this._unresolvedReferences.size) {\r\n      meta.references = sortReferences(this._unresolvedReferences.toJSON());\r\n    }\r\n    */\r\n\r\n    return meta;\r\n  }\r\n\r\n  // Manipulation\r\n\r\n  /**\r\n   * Creates a new child node.\r\n   * @param {Object} options The options to use.\r\n   * @param {string} options.extension The extension to append to the node's name.\r\n   */\r\n  public createChild({ extension }: { extension: string }): Node {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    const node: Node = new (this.constructor as any)({\r\n      name: this.idName,\r\n      parent: this,\r\n      nodeClass: this.nodeClass,\r\n    });\r\n\r\n    node.fileName = `${this.fileName}${extension}`;\r\n\r\n    node.references = this.references;\r\n    node._parentResolvesMetadata = true;\r\n\r\n    return node;\r\n  }\r\n\r\n  // Convenience getters\r\n\r\n  /**\r\n   * The node's data type.\r\n   */\r\n  public get dataType(): ItemOf<typeof DataType> {\r\n    if (!this.isVariableNode()) {\r\n      throw new TypeError('Not a variable node');\r\n    }\r\n\r\n    return this.value.dataType;\r\n  }\r\n\r\n  /**\r\n   * The node's array type.\r\n   */\r\n  public get arrayType(): ItemOf<typeof VariantArrayType> {\r\n    if (!this.isVariableNode()) {\r\n      throw new TypeError('Not a variable node');\r\n    }\r\n\r\n    return this.value.arrayType;\r\n  }\r\n\r\n  /**\r\n   * If the node is a variable.\r\n   * @deprecated Use TypeScript compatible {@link Node#isVariableNode} instead.\r\n   */\r\n  public get isVariable(): boolean {\r\n    return this.nodeClass === NodeClass.Variable;\r\n  }\r\n\r\n  public isVariableNode(): this is WithValue {\r\n    return this.isVariable;\r\n  }\r\n\r\n  // FIXME: Move to display / script transformers\r\n\r\n  /**\r\n   * If the node is an object display.\r\n   */\r\n  public get isDisplay(): boolean {\r\n    return this.hasTypeDefinition('VariableTypes.ATVISE.Display');\r\n  }\r\n\r\n  /**\r\n   * If the node is a serverside script.\r\n   */\r\n  public get isScript(): boolean {\r\n    return this.hasTypeDefinition('VariableTypes.ATVISE.ScriptCode');\r\n  }\r\n\r\n  /**\r\n   * If the node is a quickdynamic.\r\n   */\r\n  public get isQuickDynamic(): boolean {\r\n    return this.hasTypeDefinition('VariableTypes.ATVISE.QuickDynamic');\r\n  }\r\n\r\n  /**\r\n   * If the node is a display script.\r\n   */\r\n  public get isDisplayScript(): boolean {\r\n    return this.hasTypeDefinition('VariableTypes.ATVISE.DisplayScript');\r\n  }\r\n}\r\n\r\n/**\r\n * A node during a *pull*.\r\n */\r\nexport abstract class ServerNode extends Node {\r\n  /**\r\n   * The node's name.\r\n   */\r\n  public get name(): string {\r\n    return this.fileName;\r\n  }\r\n\r\n  /**\r\n   * Renames a node.\r\n   * @param name The name to set.\r\n   */\r\n  public renameTo(name: string): void {\r\n    this.fileName = name;\r\n  }\r\n}\r\n\r\n/**\r\n * A node during a *push*.\r\n */\r\nexport abstract class SourceNode extends Node {\r\n  /**\r\n   * The node's name.\r\n   */\r\n  public get name(): string {\r\n    return this.idName;\r\n  }\r\n\r\n  /**\r\n   * Renames a node.\r\n   * @param name The name to set.\r\n   */\r\n  public renameTo(name: string): void {\r\n    this.idName = name;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]}