{"version":3,"file":"dest.js","names":["_stream","require","_path","_os","_nodeclass","_fsExtra","_hasha","_interopRequireDefault","_gulplog","_ProjectConfig","_coding","e","__esModule","default","renameConfigPath","exports","renameDefaultName","hashaOptions","algorithm","useChecksums","ProjectConfig","vcs","escapePathComponent","a","replace","WriteStream","Writable","constructor","options","path","Error","Object","assign","objectMode","highWaterMark","_isDestroyed","_processed","_written","_base","base","_renameConfig","_renamesUsed","_cleanRenameConfig","cleanRenameConfig","_loadRenameConfig","readJson","then","config","catch","Logger","debug","_idMap","Map","_performWrites","_conflictingIds","Set","_discoveredIdConflicts","info","isDestroyed","_parentHasIdConflict","node","current","parent","has","nodeId","toLowerCase","_outputFile","content","oldSum","hasha","fromFile","Promise","resolve","outputFile","_writeNode","dirPath","filePath","map","writeOps","rename","id","value","renameTo","_renamed","specialId","name","match","before","pathKey","concat","fileName","join","error","get","existingRename","add","set","hasUnresolvedMetadata","nodeClass","NodeClass","Variable","key","push","JSON","stringify","metadata","noWrite","encodeVariant","all","length","_write","enc","callback","err","writeAsync","reject","_writev","nodes","chunk","_destroy","writeRenamefile","renameConfig","keys","sort","reduce","result","renamesRemoved","EOL","dest"],"sources":["../../../src/lib/gulp/dest.js"],"sourcesContent":["import { Writable } from 'stream';\r\nimport { join } from 'path';\r\nimport { EOL } from 'os';\r\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\r\nimport { outputFile, readJson } from 'fs-extra';\r\nimport hasha from 'hasha';\r\nimport Logger from 'gulplog';\r\nimport ProjectConfig from '../../config/ProjectConfig';\r\nimport { encodeVariant } from '../coding';\r\n\r\n/**\r\n * Relative path to the rename file.\r\n * @type {string}\r\n */\r\nexport const renameConfigPath = './atscm/rename.json';\r\n\r\n/**\r\n * The default name inserted into the rename file.\r\n * @type {string}\r\n */\r\nconst renameDefaultName = 'insert node name';\r\n\r\n/**\r\n * Options to pass to *hasha*.\r\n * @type {Object}\r\n */\r\nconst hashaOptions = { algorithm: 'md5' };\r\n\r\n/**\r\n * If checksums should be used to decide if writes are needed.\r\n * @type {boolean}\r\n */\r\nconst useChecksums = ProjectConfig.vcs === 'svn';\r\n\r\nconst escapePathComponent = (a) => a.replace(/\\//g, '%2F');\r\n\r\n/**\r\n * A stream that writes {@link Node}s to the file system.\r\n */\r\nexport class WriteStream extends Writable {\r\n  /**\r\n   * Creates a new WriteStream.\r\n   * @param {Object} options The options to use.\r\n   * @param {string} options.path The path to write to **(required)**.\r\n   * @param {string} options.base The base path to write to (defaults to *path*).\r\n   * @param {boolean} [options.cleanRenameConfig=false] If unused entries should be removed when\r\n   * rename config is written.\r\n   */\r\n  constructor(options) {\r\n    if (!options.path) {\r\n      throw new Error('Missing `path` option');\r\n    }\r\n\r\n    super(Object.assign({}, options, { objectMode: true, highWaterMark: 10000 }));\r\n\r\n    /**\r\n     * If the stream is destroyed.\r\n     * @type {boolean}\r\n     */\r\n    this._isDestroyed = false;\r\n\r\n    /**\r\n     * The number of processed nodes.\r\n     * @type {number}\r\n     */\r\n    this._processed = 0;\r\n\r\n    /**\r\n     * The number of written nodes.\r\n     * @type {number}\r\n     */\r\n    this._written = 0;\r\n\r\n    /**\r\n     * The base to output to.\r\n     * @type {string}\r\n     */\r\n    this._base = options.base || options.path;\r\n\r\n    /**\r\n     * The object stored in the *rename file* (usually at './atscm/rename.json')\r\n     */\r\n    this._renameConfig = {};\r\n    this._renamesUsed = {};\r\n    this._cleanRenameConfig = options.cleanRenameConfig || false;\r\n\r\n    /**\r\n     * A promise that resolves once the *rename file* is loaded.\r\n     * @type Promise<Object>\r\n     */\r\n    this._loadRenameConfig = readJson(renameConfigPath)\r\n      .then((config) => (this._renameConfig = config))\r\n      .catch(() => Logger.debug('No rename config file loaded'));\r\n\r\n    /**\r\n     * A map of ids used for renaming.\r\n     */\r\n    this._idMap = new Map();\r\n\r\n    /**\r\n     * If writes should actually be performed. Set to `false` once id conflicts were discovered.\r\n     */\r\n    this._performWrites = true;\r\n\r\n    /**\r\n     * The IDs that are affected by node id conflicts, lowercased.\r\n     * @type {Set<string>}\r\n     */\r\n    this._conflictingIds = new Set();\r\n\r\n    /**\r\n     * The number of id conflicts discovered.\r\n     * @type {number}\r\n     */\r\n    this._discoveredIdConflicts = 0;\r\n\r\n    if (useChecksums) {\r\n      Logger.info('Optimizing for SVN diffs');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If the stream is destroyed.\r\n   * @type {boolean}\r\n   */\r\n  get isDestroyed() {\r\n    return this._isDestroyed;\r\n  }\r\n\r\n  /**\r\n   * Transverses the node tree to see if any parent node has an id conflict.\r\n   * @param {ServerNode} node The processed node.\r\n   * @return {boolean} `true` if a parent node has an id conflict.\r\n   */\r\n  _parentHasIdConflict(node) {\r\n    let current = node.parent;\r\n\r\n    while (current) {\r\n      if (this._conflictingIds.has(current.nodeId.toLowerCase())) {\r\n        return true;\r\n      }\r\n      current = current.parent;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  async _outputFile(path, content) {\r\n    if (useChecksums) {\r\n      const oldSum = await hasha.fromFile(path, hashaOptions).catch(() => null);\r\n\r\n      if (oldSum) {\r\n        if (oldSum === hasha(content, hashaOptions)) {\r\n          Logger.debug(`Content did not change at ${path}`);\r\n          return Promise.resolve();\r\n        }\r\n\r\n        Logger.debug(`Content changed at ${path}`);\r\n      } else {\r\n        Logger.debug(`No checksums for ${path}`);\r\n      }\r\n    }\r\n\r\n    return outputFile(path, content);\r\n  }\r\n\r\n  /**\r\n   * Writes a single node to disk.\r\n   * @param {ServerNode} node The processed node.\r\n   * @return {Promise<boolean>} Resolves once the node has been written, `true` indicates the node\r\n   * has actually been written.\r\n   */\r\n  async _writeNode(node) {\r\n    // TODO: Throw if node.name ends with '.inner'\r\n    const dirPath = node.filePath.map(escapePathComponent);\r\n\r\n    const writeOps = [];\r\n\r\n    // Rename nodes specified in the rename config\r\n    const rename = this._renameConfig[node.id.value];\r\n    if (rename && rename !== renameDefaultName) {\r\n      this._renamesUsed[node.id.value] = true;\r\n      node.renameTo(rename);\r\n      Logger.debug(`'${node.nodeId}' was renamed to '${rename}'`);\r\n\r\n      Object.assign(node, { _renamed: true });\r\n    }\r\n\r\n    // Resolve invalid ids\r\n    if (!node._renamed && node.nodeId !== node.id.value) {\r\n      Logger.debug(\r\n        `Resolved ID conflict: '${node.id.value}' should be renamed to '${node.nodeId}'`\r\n      );\r\n    }\r\n\r\n    Object.assign(node, { specialId: node.id.value });\r\n\r\n    if (node.name.match(/:/)) {\r\n      const before = node.name;\r\n      node.renameTo(node.name.replace(/:/g, '_'));\r\n      Logger.debug(`Resolved ID conflict: '${before}' was renamed to safe name '${node.name}'`);\r\n    }\r\n\r\n    // Detect \"duplicate\" ids (as file names are case insensitive)\r\n    const pathKey = dirPath.concat(node.fileName).join('/').toLowerCase();\r\n    if (this._idMap.has(pathKey)) {\r\n      if (this._parentHasIdConflict(node)) {\r\n        Logger.debug(`ID conflict: Skipping '${node.nodeId}'`);\r\n      } else {\r\n        Logger.error(`ID conflict: '${node.nodeId}' conflicts with '${this._idMap.get(pathKey)}'`);\r\n\r\n        this._discoveredIdConflicts++;\r\n\r\n        const existingRename = this._renameConfig[node.nodeId];\r\n        if (existingRename) {\r\n          if (existingRename === renameDefaultName) {\r\n            // eslint-disable-next-line max-len\r\n            Logger.error(\r\n              ` - '${node.nodeId}' is present inside the rename file at './atscm/rename.json', but no name has been inserted yet.`\r\n            );\r\n          } else {\r\n            // eslint-disable-next-line max-len\r\n            Logger.error(\r\n              ` - The name for '${node.nodeId}' inside './atscm/rename.json' is not unique.`\r\n            );\r\n          }\r\n\r\n          Logger.info(\" - Edit the node's name and run 'atscm pull' again\");\r\n        } else {\r\n          this._renameConfig[node.nodeId] = renameDefaultName;\r\n          Logger.info(` - '${node.nodeId}' was added to the rename file at './atscm/rename.json'`);\r\n          Logger.info(\"Edit it's name and run 'atscm pull' again.\");\r\n        }\r\n      }\r\n\r\n      this._conflictingIds.add(node.nodeId.toLowerCase());\r\n      this._performWrites = false;\r\n    } else {\r\n      this._idMap.set(pathKey, node.nodeId);\r\n    }\r\n\r\n    // Write definition file (if needed)\r\n    if (node.hasUnresolvedMetadata) {\r\n      const name =\r\n        node.nodeClass === NodeClass.Variable\r\n          ? `./.${escapePathComponent(node.fileName)}.json`\r\n          : `./${escapePathComponent(node.fileName)}/.${node.nodeClass.key}.json`;\r\n\r\n      if (this._performWrites) {\r\n        writeOps.push(\r\n          this._outputFile(\r\n            join(this._base, dirPath.join('/'), name),\r\n            JSON.stringify(node.metadata, null, '  ')\r\n          )\r\n        );\r\n      }\r\n    }\r\n\r\n    // Write value\r\n    if (node.nodeClass === NodeClass.Variable) {\r\n      if (node.value) {\r\n        if (!node.value.noWrite) {\r\n          if (this._performWrites) {\r\n            writeOps.push(\r\n              this._outputFile(\r\n                join(this._base, dirPath.join('/'), escapePathComponent(node.fileName)),\r\n                encodeVariant(node.value)\r\n              )\r\n            );\r\n          }\r\n\r\n          // Store child nodes as file.inner/...\r\n          node.renameTo(`${node.name}.inner`);\r\n        }\r\n      } else {\r\n        throw new Error('Missing value');\r\n      }\r\n    }\r\n\r\n    return Promise.all(writeOps)\r\n      .then(() => {\r\n        this._processed++;\r\n        this._written += writeOps.length;\r\n      })\r\n      .then(() => writeOps.length > 0);\r\n  }\r\n\r\n  /**\r\n   * Writes a single node to the file system.\r\n   * @param {Node} node The node to write.\r\n   * @param {string} enc The encoding used.\r\n   * @param {function(err: ?Error): void} callback Called once finished.\r\n   */\r\n  _write(node, enc, callback) {\r\n    this._loadRenameConfig\r\n      .then(() => this._writeNode(node))\r\n      .then(() => callback())\r\n      .catch((err) => callback(err));\r\n  }\r\n\r\n  writeAsync(node) {\r\n    return new Promise((resolve, reject) => {\r\n      this._write(node, null, (err) => (err ? reject(err) : resolve()));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Writes multiple nodes in parallel.\r\n   * @param {Node[]} nodes The nodes to write.\r\n   * @param {function(error: ?Error): void} callback Called once all nodes have been written.\r\n   */\r\n  _writev(nodes, callback) {\r\n    if (this.isDestroyed) {\r\n      return;\r\n    }\r\n\r\n    this._loadRenameConfig\r\n      .then(() => Promise.all(nodes.map(({ chunk }) => this._writeNode(chunk))))\r\n      .then(() => callback())\r\n      .catch((err) => callback(err));\r\n  }\r\n\r\n  /**\r\n   * Destroys the stream.\r\n   * @param {?Error} err The error that caused the destroy.\r\n   * @param {function(err: ?Error): void} callback Called once finished.\r\n   */\r\n  _destroy(err, callback) {\r\n    this._isDestroyed = true;\r\n    super._destroy(err, callback);\r\n  }\r\n\r\n  /**\r\n   * Writes the updated rename config to disk.\r\n   */\r\n  writeRenamefile() {\r\n    if (this._discoveredIdConflicts) {\r\n      Logger.error(\r\n        `Discovered ${this._discoveredIdConflicts} node id conflicts, results are incomplete.\r\n - Resolve all conflicts inside '${renameConfigPath}' and run 'atscm pull' again`\r\n      );\r\n      // FIXME: Insert link to node id conflict manual here once 1.0.0 is released.\r\n    }\r\n\r\n    let renameConfig = this._renameConfig;\r\n    if (!this._discoveredIdConflicts && this._cleanRenameConfig) {\r\n      renameConfig = Object.keys(this._renamesUsed)\r\n        .sort()\r\n        .reduce(\r\n          (result, key) =>\r\n            Object.assign(result, {\r\n              [key]: this._renameConfig[key],\r\n            }),\r\n          {}\r\n        );\r\n\r\n      const renamesRemoved =\r\n        Object.keys(this._renameConfig).length - Object.keys(renameConfig).length;\r\n\r\n      if (renamesRemoved > 0) {\r\n        Logger.info(`Removed ${renamesRemoved} unused renames from rename configuration.`);\r\n      }\r\n    }\r\n\r\n    return outputFile(renameConfigPath, `${JSON.stringify(renameConfig, null, '  ')}${EOL}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a new {@link WriteStream} to write to *path*.\r\n * @param {string} path The path to write to.\r\n * @param {Object} [options] The options to use. Passed to {@link WriteStream#constructor}.\r\n */\r\nexport default function dest(path, { cleanRenameConfig = false } = {}) {\r\n  return new WriteStream({ path, cleanRenameConfig });\r\n}\r\n"],"mappings":";;;;;;;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AACA,IAAAE,GAAA,GAAAF,OAAA;AACA,IAAAG,UAAA,GAAAH,OAAA;AACA,IAAAI,QAAA,GAAAJ,OAAA;AACA,IAAAK,MAAA,GAAAC,sBAAA,CAAAN,OAAA;AACA,IAAAO,QAAA,GAAAD,sBAAA,CAAAN,OAAA;AACA,IAAAQ,cAAA,GAAAF,sBAAA,CAAAN,OAAA;AACA,IAAAS,OAAA,GAAAT,OAAA;AAA0C,SAAAM,uBAAAI,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,KAAAE,OAAA,EAAAF,CAAA;AAE1C;AACA;AACA;AACA;AACO,MAAMG,gBAAgB,GAAAC,OAAA,CAAAD,gBAAA,GAAG,qBAAqB;;AAErD;AACA;AACA;AACA;AACA,MAAME,iBAAiB,GAAG,kBAAkB;;AAE5C;AACA;AACA;AACA;AACA,MAAMC,YAAY,GAAG;EAAEC,SAAS,EAAE;AAAM,CAAC;;AAEzC;AACA;AACA;AACA;AACA,MAAMC,YAAY,GAAGC,sBAAa,CAACC,GAAG,KAAK,KAAK;AAEhD,MAAMC,mBAAmB,GAAIC,CAAC,IAAKA,CAAC,CAACC,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC;;AAE1D;AACA;AACA;AACO,MAAMC,WAAW,SAASC,gBAAQ,CAAC;EACxC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAACC,OAAO,EAAE;IACnB,IAAI,CAACA,OAAO,CAACC,IAAI,EAAE;MACjB,MAAM,IAAIC,KAAK,CAAC,uBAAuB,CAAC;IAC1C;IAEA,KAAK,CAACC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEJ,OAAO,EAAE;MAAEK,UAAU,EAAE,IAAI;MAAEC,aAAa,EAAE;IAAM,CAAC,CAAC,CAAC;;IAE7E;AACJ;AACA;AACA;IACI,IAAI,CAACC,YAAY,GAAG,KAAK;;IAEzB;AACJ;AACA;AACA;IACI,IAAI,CAACC,UAAU,GAAG,CAAC;;IAEnB;AACJ;AACA;AACA;IACI,IAAI,CAACC,QAAQ,GAAG,CAAC;;IAEjB;AACJ;AACA;AACA;IACI,IAAI,CAACC,KAAK,GAAGV,OAAO,CAACW,IAAI,IAAIX,OAAO,CAACC,IAAI;;IAEzC;AACJ;AACA;IACI,IAAI,CAACW,aAAa,GAAG,CAAC,CAAC;IACvB,IAAI,CAACC,YAAY,GAAG,CAAC,CAAC;IACtB,IAAI,CAACC,kBAAkB,GAAGd,OAAO,CAACe,iBAAiB,IAAI,KAAK;;IAE5D;AACJ;AACA;AACA;IACI,IAAI,CAACC,iBAAiB,GAAG,IAAAC,iBAAQ,EAAC/B,gBAAgB,CAAC,CAChDgC,IAAI,CAAEC,MAAM,IAAM,IAAI,CAACP,aAAa,GAAGO,MAAO,CAAC,CAC/CC,KAAK,CAAC,MAAMC,gBAAM,CAACC,KAAK,CAAC,8BAA8B,CAAC,CAAC;;IAE5D;AACJ;AACA;IACI,IAAI,CAACC,MAAM,GAAG,IAAIC,GAAG,CAAC,CAAC;;IAEvB;AACJ;AACA;IACI,IAAI,CAACC,cAAc,GAAG,IAAI;;IAE1B;AACJ;AACA;AACA;IACI,IAAI,CAACC,eAAe,GAAG,IAAIC,GAAG,CAAC,CAAC;;IAEhC;AACJ;AACA;AACA;IACI,IAAI,CAACC,sBAAsB,GAAG,CAAC;IAE/B,IAAIrC,YAAY,EAAE;MAChB8B,gBAAM,CAACQ,IAAI,CAAC,0BAA0B,CAAC;IACzC;EACF;;EAEA;AACF;AACA;AACA;EACE,IAAIC,WAAWA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACvB,YAAY;EAC1B;;EAEA;AACF;AACA;AACA;AACA;EACEwB,oBAAoBA,CAACC,IAAI,EAAE;IACzB,IAAIC,OAAO,GAAGD,IAAI,CAACE,MAAM;IAEzB,OAAOD,OAAO,EAAE;MACd,IAAI,IAAI,CAACP,eAAe,CAACS,GAAG,CAACF,OAAO,CAACG,MAAM,CAACC,WAAW,CAAC,CAAC,CAAC,EAAE;QAC1D,OAAO,IAAI;MACb;MACAJ,OAAO,GAAGA,OAAO,CAACC,MAAM;IAC1B;IAEA,OAAO,KAAK;EACd;EAEA,MAAMI,WAAWA,CAACrC,IAAI,EAAEsC,OAAO,EAAE;IAC/B,IAAIhD,YAAY,EAAE;MAChB,MAAMiD,MAAM,GAAG,MAAMC,cAAK,CAACC,QAAQ,CAACzC,IAAI,EAAEZ,YAAY,CAAC,CAAC+B,KAAK,CAAC,MAAM,IAAI,CAAC;MAEzE,IAAIoB,MAAM,EAAE;QACV,IAAIA,MAAM,KAAK,IAAAC,cAAK,EAACF,OAAO,EAAElD,YAAY,CAAC,EAAE;UAC3CgC,gBAAM,CAACC,KAAK,CAAC,6BAA6BrB,IAAI,EAAE,CAAC;UACjD,OAAO0C,OAAO,CAACC,OAAO,CAAC,CAAC;QAC1B;QAEAvB,gBAAM,CAACC,KAAK,CAAC,sBAAsBrB,IAAI,EAAE,CAAC;MAC5C,CAAC,MAAM;QACLoB,gBAAM,CAACC,KAAK,CAAC,oBAAoBrB,IAAI,EAAE,CAAC;MAC1C;IACF;IAEA,OAAO,IAAA4C,mBAAU,EAAC5C,IAAI,EAAEsC,OAAO,CAAC;EAClC;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMO,UAAUA,CAACd,IAAI,EAAE;IACrB;IACA,MAAMe,OAAO,GAAGf,IAAI,CAACgB,QAAQ,CAACC,GAAG,CAACvD,mBAAmB,CAAC;IAEtD,MAAMwD,QAAQ,GAAG,EAAE;;IAEnB;IACA,MAAMC,MAAM,GAAG,IAAI,CAACvC,aAAa,CAACoB,IAAI,CAACoB,EAAE,CAACC,KAAK,CAAC;IAChD,IAAIF,MAAM,IAAIA,MAAM,KAAK/D,iBAAiB,EAAE;MAC1C,IAAI,CAACyB,YAAY,CAACmB,IAAI,CAACoB,EAAE,CAACC,KAAK,CAAC,GAAG,IAAI;MACvCrB,IAAI,CAACsB,QAAQ,CAACH,MAAM,CAAC;MACrB9B,gBAAM,CAACC,KAAK,CAAC,IAAIU,IAAI,CAACI,MAAM,qBAAqBe,MAAM,GAAG,CAAC;MAE3DhD,MAAM,CAACC,MAAM,CAAC4B,IAAI,EAAE;QAAEuB,QAAQ,EAAE;MAAK,CAAC,CAAC;IACzC;;IAEA;IACA,IAAI,CAACvB,IAAI,CAACuB,QAAQ,IAAIvB,IAAI,CAACI,MAAM,KAAKJ,IAAI,CAACoB,EAAE,CAACC,KAAK,EAAE;MACnDhC,gBAAM,CAACC,KAAK,CACV,0BAA0BU,IAAI,CAACoB,EAAE,CAACC,KAAK,2BAA2BrB,IAAI,CAACI,MAAM,GAC/E,CAAC;IACH;IAEAjC,MAAM,CAACC,MAAM,CAAC4B,IAAI,EAAE;MAAEwB,SAAS,EAAExB,IAAI,CAACoB,EAAE,CAACC;IAAM,CAAC,CAAC;IAEjD,IAAIrB,IAAI,CAACyB,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC,EAAE;MACxB,MAAMC,MAAM,GAAG3B,IAAI,CAACyB,IAAI;MACxBzB,IAAI,CAACsB,QAAQ,CAACtB,IAAI,CAACyB,IAAI,CAAC7D,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;MAC3CyB,gBAAM,CAACC,KAAK,CAAC,0BAA0BqC,MAAM,+BAA+B3B,IAAI,CAACyB,IAAI,GAAG,CAAC;IAC3F;;IAEA;IACA,MAAMG,OAAO,GAAGb,OAAO,CAACc,MAAM,CAAC7B,IAAI,CAAC8B,QAAQ,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC1B,WAAW,CAAC,CAAC;IACrE,IAAI,IAAI,CAACd,MAAM,CAACY,GAAG,CAACyB,OAAO,CAAC,EAAE;MAC5B,IAAI,IAAI,CAAC7B,oBAAoB,CAACC,IAAI,CAAC,EAAE;QACnCX,gBAAM,CAACC,KAAK,CAAC,0BAA0BU,IAAI,CAACI,MAAM,GAAG,CAAC;MACxD,CAAC,MAAM;QACLf,gBAAM,CAAC2C,KAAK,CAAC,iBAAiBhC,IAAI,CAACI,MAAM,qBAAqB,IAAI,CAACb,MAAM,CAAC0C,GAAG,CAACL,OAAO,CAAC,GAAG,CAAC;QAE1F,IAAI,CAAChC,sBAAsB,EAAE;QAE7B,MAAMsC,cAAc,GAAG,IAAI,CAACtD,aAAa,CAACoB,IAAI,CAACI,MAAM,CAAC;QACtD,IAAI8B,cAAc,EAAE;UAClB,IAAIA,cAAc,KAAK9E,iBAAiB,EAAE;YACxC;YACAiC,gBAAM,CAAC2C,KAAK,CACV,OAAOhC,IAAI,CAACI,MAAM,kGACpB,CAAC;UACH,CAAC,MAAM;YACL;YACAf,gBAAM,CAAC2C,KAAK,CACV,oBAAoBhC,IAAI,CAACI,MAAM,+CACjC,CAAC;UACH;UAEAf,gBAAM,CAACQ,IAAI,CAAC,oDAAoD,CAAC;QACnE,CAAC,MAAM;UACL,IAAI,CAACjB,aAAa,CAACoB,IAAI,CAACI,MAAM,CAAC,GAAGhD,iBAAiB;UACnDiC,gBAAM,CAACQ,IAAI,CAAC,OAAOG,IAAI,CAACI,MAAM,yDAAyD,CAAC;UACxFf,gBAAM,CAACQ,IAAI,CAAC,4CAA4C,CAAC;QAC3D;MACF;MAEA,IAAI,CAACH,eAAe,CAACyC,GAAG,CAACnC,IAAI,CAACI,MAAM,CAACC,WAAW,CAAC,CAAC,CAAC;MACnD,IAAI,CAACZ,cAAc,GAAG,KAAK;IAC7B,CAAC,MAAM;MACL,IAAI,CAACF,MAAM,CAAC6C,GAAG,CAACR,OAAO,EAAE5B,IAAI,CAACI,MAAM,CAAC;IACvC;;IAEA;IACA,IAAIJ,IAAI,CAACqC,qBAAqB,EAAE;MAC9B,MAAMZ,IAAI,GACRzB,IAAI,CAACsC,SAAS,KAAKC,oBAAS,CAACC,QAAQ,GACjC,MAAM9E,mBAAmB,CAACsC,IAAI,CAAC8B,QAAQ,CAAC,OAAO,GAC/C,KAAKpE,mBAAmB,CAACsC,IAAI,CAAC8B,QAAQ,CAAC,KAAK9B,IAAI,CAACsC,SAAS,CAACG,GAAG,OAAO;MAE3E,IAAI,IAAI,CAAChD,cAAc,EAAE;QACvByB,QAAQ,CAACwB,IAAI,CACX,IAAI,CAACpC,WAAW,CACd,IAAAyB,UAAI,EAAC,IAAI,CAACrD,KAAK,EAAEqC,OAAO,CAACgB,IAAI,CAAC,GAAG,CAAC,EAAEN,IAAI,CAAC,EACzCkB,IAAI,CAACC,SAAS,CAAC5C,IAAI,CAAC6C,QAAQ,EAAE,IAAI,EAAE,IAAI,CAC1C,CACF,CAAC;MACH;IACF;;IAEA;IACA,IAAI7C,IAAI,CAACsC,SAAS,KAAKC,oBAAS,CAACC,QAAQ,EAAE;MACzC,IAAIxC,IAAI,CAACqB,KAAK,EAAE;QACd,IAAI,CAACrB,IAAI,CAACqB,KAAK,CAACyB,OAAO,EAAE;UACvB,IAAI,IAAI,CAACrD,cAAc,EAAE;YACvByB,QAAQ,CAACwB,IAAI,CACX,IAAI,CAACpC,WAAW,CACd,IAAAyB,UAAI,EAAC,IAAI,CAACrD,KAAK,EAAEqC,OAAO,CAACgB,IAAI,CAAC,GAAG,CAAC,EAAErE,mBAAmB,CAACsC,IAAI,CAAC8B,QAAQ,CAAC,CAAC,EACvE,IAAAiB,qBAAa,EAAC/C,IAAI,CAACqB,KAAK,CAC1B,CACF,CAAC;UACH;;UAEA;UACArB,IAAI,CAACsB,QAAQ,CAAC,GAAGtB,IAAI,CAACyB,IAAI,QAAQ,CAAC;QACrC;MACF,CAAC,MAAM;QACL,MAAM,IAAIvD,KAAK,CAAC,eAAe,CAAC;MAClC;IACF;IAEA,OAAOyC,OAAO,CAACqC,GAAG,CAAC9B,QAAQ,CAAC,CACzBhC,IAAI,CAAC,MAAM;MACV,IAAI,CAACV,UAAU,EAAE;MACjB,IAAI,CAACC,QAAQ,IAAIyC,QAAQ,CAAC+B,MAAM;IAClC,CAAC,CAAC,CACD/D,IAAI,CAAC,MAAMgC,QAAQ,CAAC+B,MAAM,GAAG,CAAC,CAAC;EACpC;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEC,MAAMA,CAAClD,IAAI,EAAEmD,GAAG,EAAEC,QAAQ,EAAE;IAC1B,IAAI,CAACpE,iBAAiB,CACnBE,IAAI,CAAC,MAAM,IAAI,CAAC4B,UAAU,CAACd,IAAI,CAAC,CAAC,CACjCd,IAAI,CAAC,MAAMkE,QAAQ,CAAC,CAAC,CAAC,CACtBhE,KAAK,CAAEiE,GAAG,IAAKD,QAAQ,CAACC,GAAG,CAAC,CAAC;EAClC;EAEAC,UAAUA,CAACtD,IAAI,EAAE;IACf,OAAO,IAAIW,OAAO,CAAC,CAACC,OAAO,EAAE2C,MAAM,KAAK;MACtC,IAAI,CAACL,MAAM,CAAClD,IAAI,EAAE,IAAI,EAAGqD,GAAG,IAAMA,GAAG,GAAGE,MAAM,CAACF,GAAG,CAAC,GAAGzC,OAAO,CAAC,CAAE,CAAC;IACnE,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;EACE4C,OAAOA,CAACC,KAAK,EAAEL,QAAQ,EAAE;IACvB,IAAI,IAAI,CAACtD,WAAW,EAAE;MACpB;IACF;IAEA,IAAI,CAACd,iBAAiB,CACnBE,IAAI,CAAC,MAAMyB,OAAO,CAACqC,GAAG,CAACS,KAAK,CAACxC,GAAG,CAAC,CAAC;MAAEyC;IAAM,CAAC,KAAK,IAAI,CAAC5C,UAAU,CAAC4C,KAAK,CAAC,CAAC,CAAC,CAAC,CACzExE,IAAI,CAAC,MAAMkE,QAAQ,CAAC,CAAC,CAAC,CACtBhE,KAAK,CAAEiE,GAAG,IAAKD,QAAQ,CAACC,GAAG,CAAC,CAAC;EAClC;;EAEA;AACF;AACA;AACA;AACA;EACEM,QAAQA,CAACN,GAAG,EAAED,QAAQ,EAAE;IACtB,IAAI,CAAC7E,YAAY,GAAG,IAAI;IACxB,KAAK,CAACoF,QAAQ,CAACN,GAAG,EAAED,QAAQ,CAAC;EAC/B;;EAEA;AACF;AACA;EACEQ,eAAeA,CAAA,EAAG;IAChB,IAAI,IAAI,CAAChE,sBAAsB,EAAE;MAC/BP,gBAAM,CAAC2C,KAAK,CACV,cAAc,IAAI,CAACpC,sBAAsB;AACjD,mCAAmC1C,gBAAgB,8BAC7C,CAAC;MACD;IACF;IAEA,IAAI2G,YAAY,GAAG,IAAI,CAACjF,aAAa;IACrC,IAAI,CAAC,IAAI,CAACgB,sBAAsB,IAAI,IAAI,CAACd,kBAAkB,EAAE;MAC3D+E,YAAY,GAAG1F,MAAM,CAAC2F,IAAI,CAAC,IAAI,CAACjF,YAAY,CAAC,CAC1CkF,IAAI,CAAC,CAAC,CACNC,MAAM,CACL,CAACC,MAAM,EAAExB,GAAG,KACVtE,MAAM,CAACC,MAAM,CAAC6F,MAAM,EAAE;QACpB,CAACxB,GAAG,GAAG,IAAI,CAAC7D,aAAa,CAAC6D,GAAG;MAC/B,CAAC,CAAC,EACJ,CAAC,CACH,CAAC;MAEH,MAAMyB,cAAc,GAClB/F,MAAM,CAAC2F,IAAI,CAAC,IAAI,CAAClF,aAAa,CAAC,CAACqE,MAAM,GAAG9E,MAAM,CAAC2F,IAAI,CAACD,YAAY,CAAC,CAACZ,MAAM;MAE3E,IAAIiB,cAAc,GAAG,CAAC,EAAE;QACtB7E,gBAAM,CAACQ,IAAI,CAAC,WAAWqE,cAAc,4CAA4C,CAAC;MACpF;IACF;IAEA,OAAO,IAAArD,mBAAU,EAAC3D,gBAAgB,EAAE,GAAGyF,IAAI,CAACC,SAAS,CAACiB,YAAY,EAAE,IAAI,EAAE,IAAI,CAAC,GAAGM,OAAG,EAAE,CAAC;EAC1F;AACF;;AAEA;AACA;AACA;AACA;AACA;AAJAhH,OAAA,CAAAU,WAAA,GAAAA,WAAA;AAKe,SAASuG,IAAIA,CAACnG,IAAI,EAAE;EAAEc,iBAAiB,GAAG;AAAM,CAAC,GAAG,CAAC,CAAC,EAAE;EACrE,OAAO,IAAIlB,WAAW,CAAC;IAAEI,IAAI;IAAEc;EAAkB,CAAC,CAAC;AACrD","ignoreList":[]}