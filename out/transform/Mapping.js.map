{"version":3,"file":"Mapping.js","names":["_path","require","_assert","_interopRequireDefault","_nodeOpcua","_Transformer","e","__esModule","default","standardTypes","extension","dataType","DataType","ByteString","XmlElement","extensionForDataType","Boolean","key","SByte","Byte","Int16","UInt16","Int32","UInt32","Int64","UInt64","Float","Double","String","DateTime","Guid","NodeId","ExpandedNodeId","StatusCode","QualifiedName","LocalizedText","ExtensionObject","DataValue","Variant","DiagnosticInfo","extensionForArrayType","VariantArrayType","Array","Matrix","MappingTransformer","Transformer","constructor","options","_readReferenceFiles","transformFromDB","node","encoding","callback","fullyMapped","parentResolvesMetadata","typeDefinition","isStandardTypeNode","def","Object","entries","isVariable","renameTo","name","fileName","endsWith","Error","nodeId","type","ext","value","arrayType","ignore","Set","c","parent","_compactMappingApplied","has","id","assign","transformFromFilesystem","basename","assert","equal","transformsReferenceConfigFiles","exports"],"sources":["../../src/transform/Mapping.js"],"sourcesContent":["import { basename } from 'path';\r\nimport assert from 'assert';\r\nimport { VariantArrayType, DataType } from 'node-opcua';\r\nimport Transformer from '../lib/transform/Transformer';\r\n\r\n/**\r\n * Atvise specific types that need special extensions.\r\n * @type {Map<string, Object>}\r\n */\r\nconst standardTypes = {\r\n  'VariableTypes.ATVISE.HtmlHelp': {\r\n    extension: '.help.html',\r\n    dataType: DataType.ByteString,\r\n  },\r\n  'VariableTypes.ATVISE.TranslationTable': {\r\n    extension: '.locs.xml',\r\n    dataType: DataType.XmlElement,\r\n  },\r\n};\r\n\r\n/**\r\n * Extensions to use for {@link node-opcua~DataType}s.\r\n * @type {Map<string, string>}\r\n */\r\nconst extensionForDataType = {\r\n  [DataType.Boolean.key]: '.bool',\r\n  [DataType.SByte.key]: '.sbyte',\r\n  [DataType.Byte.key]: '.byte',\r\n  [DataType.Int16.key]: '.int16',\r\n  [DataType.UInt16.key]: '.uint16',\r\n  [DataType.Int32.key]: '.int32',\r\n  [DataType.UInt32.key]: '.uint32',\r\n  [DataType.Int64.key]: '.int64',\r\n  [DataType.UInt64.key]: '.uint64',\r\n  [DataType.Float.key]: '.float',\r\n  [DataType.Double.key]: '.double',\r\n  [DataType.String.key]: '.string',\r\n  [DataType.DateTime.key]: '.datetime',\r\n  [DataType.Guid.key]: '.guid',\r\n  // [DataType.ByteString.key]: '.bytestring',\r\n  [DataType.XmlElement.key]: '.xml',\r\n  [DataType.NodeId.key]: '.nodeid',\r\n  [DataType.ExpandedNodeId.key]: '.enodeid',\r\n  [DataType.StatusCode.key]: '.status',\r\n  [DataType.QualifiedName.key]: '.name',\r\n  [DataType.LocalizedText.key]: '.text',\r\n  [DataType.ExtensionObject.key]: '.obj',\r\n  [DataType.DataValue.key]: '.value',\r\n  [DataType.Variant.key]: '.variant',\r\n  [DataType.DiagnosticInfo.key]: '.info',\r\n};\r\n\r\n/**\r\n * Extensions to use for {@link node-opcua~VariantArrayType}s.\r\n * @type {Map<string, string>}\r\n */\r\nconst extensionForArrayType = {\r\n  [VariantArrayType.Array.key]: '.array',\r\n  [VariantArrayType.Matrix.key]: '.matrix',\r\n};\r\n\r\n/**\r\n * A Transformer that maps {@link ReadStream.ReadResult}s to {@link AtviseFile}s.\r\n */\r\nexport default class MappingTransformer extends Transformer {\r\n  /**\r\n   * Creates a new mapping transformer.\r\n   * @param {Object} [options] The arguments passed to the {@link Transformer} constructor.\r\n   */\r\n  constructor(options = {}) {\r\n    super(options);\r\n\r\n    /**\r\n     * Contents of the reference files read but not used yet.\r\n     * @type {Object}\r\n     */\r\n    this._readReferenceFiles = {};\r\n  }\r\n\r\n  /**\r\n   * Writes an {@link AtviseFile} for each {@link ReadStream.ReadResult} read. If a read file has a\r\n   * non-standard type (definition) an additional `rc` file is pushed holding this type.\r\n   * @param {Node} node The read result to create the file for.\r\n   * @param {string} encoding The encoding used.\r\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the error that occurred\r\n   * while transforming the read result or the resulting file.\r\n   */\r\n  transformFromDB(node, encoding, callback) {\r\n    if (!node.fullyMapped && !node.parentResolvesMetadata) {\r\n      // Skip mapping for e.g. split files\r\n      const typeDefinition = node.typeDefinition;\r\n      let isStandardTypeNode = false;\r\n\r\n      // Add extensions for standard types\r\n      for (const [def, { extension }] of Object.entries(standardTypes)) {\r\n        if (node.isVariable && typeDefinition === def) {\r\n          node.renameTo(`${node.name}${extension}`);\r\n          isStandardTypeNode = true;\r\n\r\n          // FIXME: Set dataType and mark as resolved\r\n          // FIXME: Set typeDefinition and mark as resolved\r\n        } else if (node.fileName.endsWith(extension)) {\r\n          callback(new Error(`Name conflict: ${node.nodeId} should not end with '${extension}'`));\r\n          return;\r\n        }\r\n      }\r\n\r\n      // Add extensions for data types\r\n      for (const [type, ext] of Object.entries(extensionForDataType)) {\r\n        if (node.isVariable && node.value && node.value.dataType.key === type) {\r\n          if (!isStandardTypeNode) {\r\n            node.renameTo(`${node.name}${ext}`);\r\n            break;\r\n          }\r\n\r\n          // FIXME: Set dataType and mark as resolved\r\n        }\r\n      }\r\n\r\n      // Add extensions for array types\r\n      for (const [type, ext] of Object.entries(extensionForArrayType)) {\r\n        if (node.isVariable && node.value.arrayType.key === type) {\r\n          if (!isStandardTypeNode) {\r\n            node.renameTo(`${node.name}${ext}`);\r\n          }\r\n\r\n          // FIXME: Set arrayType and mark as resolved\r\n        } else if (node.fileName.endsWith(ext)) {\r\n          callback(new Error(`Name conflict: ${node.nodeId} should not end with '${ext}'`));\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Compact mapping: Root source folders are AGENT, SYSTEM, ObjectTypes and VariableTypes\r\n    // FIXME: Make optional\r\n    const ignore = new Set([\r\n      58, // Objects -> Types -> BaseObjectType\r\n      62, // Objects -> Types -> BaseVariableType\r\n      85, // Objects\r\n      86, // Objects -> Types\r\n    ]);\r\n\r\n    for (let c = node; c && c.parent && !c._compactMappingApplied; c = c.parent) {\r\n      if (ignore.has(c.parent.id.value)) {\r\n        c.parent = c.parent.parent;\r\n        c = node;\r\n      }\r\n    }\r\n\r\n    Object.assign(node, {\r\n      _compactMappingApplied: true,\r\n    });\r\n\r\n    callback(null, node);\r\n  }\r\n\r\n  /**\r\n   * Writes an {@link AtviseFile} for each {@link Node} read.\r\n   * @param {Node} node The raw file.\r\n   * @param {string} encoding The encoding used.\r\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the error that occurred\r\n   * while transforming the read result or the resulting file.\r\n   */\r\n  transformFromFilesystem(node, encoding, callback) {\r\n    let isStandardTypeNode = false;\r\n\r\n    // Resolve standard type from extension\r\n    for (const [, { extension }] of Object.entries(standardTypes)) {\r\n      if (node.name.endsWith(extension)) {\r\n        isStandardTypeNode = true;\r\n\r\n        // FIXME: Set dataType and mark as resolved\r\n        // FIXME: Set typeDefinition and mark as resolved\r\n\r\n        node.renameTo(basename(node.name, extension));\r\n      }\r\n    }\r\n\r\n    // Resolve arrayType from extension\r\n    for (const [type, extension] of Object.entries(extensionForArrayType)) {\r\n      if (node.name.endsWith(extension) && !isStandardTypeNode) {\r\n        assert.equal(node.arrayType.key, type);\r\n\r\n        // FIXME: Set arrayType and mark as resolved\r\n\r\n        node.renameTo(basename(node.name, extension));\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Resolve dataType from extension\r\n    for (const [type, extension] of Object.entries(extensionForDataType)) {\r\n      if (node.name.endsWith(extension) && !isStandardTypeNode && node.dataType.key === type) {\r\n        // FIXME: Set dataType and mark as resolved\r\n\r\n        node.renameTo(basename(node.name, extension));\r\n        break;\r\n      }\r\n    }\r\n\r\n    return callback(null, node);\r\n  }\r\n\r\n  /**\r\n   * `true` as the mapping transformer should infer references from config files.\r\n   */\r\n  get transformsReferenceConfigFiles() {\r\n    return true;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]}