{"version":3,"file":"AlarmConfigTransformer.js","names":["_PartialTransformer","_interopRequireDefault","require","e","__esModule","default","limitNodeNameRegExp","getLimitTriggerType","node","parent","dataType","LintTransformer","PartialTransformer","shouldBeTransformed","Boolean","hasTypeDefinition","nodeId","match","transformFromDB","remove","triggerDataType","transformFromFilesystem","exports"],"sources":["../../src/transform/AlarmConfigTransformer.ts"],"sourcesContent":["import { DataType } from 'node-opcua/lib/datamodel/variant';\r\nimport { ItemOf } from 'node-opcua/lib/misc/enum.js';\r\nimport PartialTransformer from '../lib/transform/PartialTransformer';\r\nimport Node from '../lib/model/Node';\r\n\r\nconst limitNodeNameRegExp = /\\.(upper|lower)_limit(_deadband)?$/;\r\n\r\n/**\r\n * Returns an alarm limit's trigger / source node's data type.\r\n * Assuming a regular project structure this is the third parent node:\r\n * **Source** > AlarmConfiguration > AlarmCondition > FilterNode.\r\n * @param node The limit node to check.\r\n */\r\nfunction getLimitTriggerType(node: Node): ItemOf<typeof DataType> | undefined {\r\n  return (\r\n    node &&\r\n    node.parent &&\r\n    node.parent.parent &&\r\n    node.parent.parent.parent &&\r\n    node.parent.parent.parent.dataType\r\n  );\r\n}\r\n\r\n/**\r\n * A transformer ensuring no invalid alarm condition filter nodes are pulled.\r\n */\r\nexport default class LintTransformer extends PartialTransformer {\r\n  /**\r\n   * Returns `true` for all alarm condition filter nodes.\r\n   * @param node The node to check.\r\n   */\r\n  public shouldBeTransformed(node: Node): boolean {\r\n    return Boolean(\r\n      node.parent &&\r\n        node.parent.hasTypeDefinition('ObjectTypes.ATVISE.AlarmConditionControl.Limit') &&\r\n        node.nodeId.match(limitNodeNameRegExp)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Removes filter alarm condition filter nodes that have an invalid dataType.\r\n   * @param node The node to transform.\r\n   * @param context The transform context.\r\n   */\r\n  public async transformFromDB(node: Node, { remove }: { remove: () => void }): Promise<void> {\r\n    if (!this.shouldBeTransformed(node)) return;\r\n\r\n    const triggerDataType = getLimitTriggerType(node);\r\n\r\n    // NOTE: When no trigger node was found, the node is ignored as well\r\n    // This means that during incomplete pulls (e.g. in response to a watch event) these nodes are\r\n    // not updated.\r\n    if (node.dataType !== triggerDataType) {\r\n      remove();\r\n    }\r\n  }\r\n\r\n  /** Does nothing. */\r\n  public async transformFromFilesystem(): Promise<void> {\r\n    return;\r\n  }\r\n}\r\n"],"mappings":";;;;;;AAEA,IAAAA,mBAAA,GAAAC,sBAAA,CAAAC,OAAA;AAAqE,SAAAD,uBAAAE,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,KAAAE,OAAA,EAAAF,CAAA;AAGrE,MAAMG,mBAAmB,GAAG,oCAAoC;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,CAACC,IAAU,EAAuC;EAC5E,OACEA,IAAI,IACJA,IAAI,CAACC,MAAM,IACXD,IAAI,CAACC,MAAM,CAACA,MAAM,IAClBD,IAAI,CAACC,MAAM,CAACA,MAAM,CAACA,MAAM,IACzBD,IAAI,CAACC,MAAM,CAACA,MAAM,CAACA,MAAM,CAACC,QAAQ;AAEtC;;AAEA;AACA;AACA;AACe,MAAMC,eAAe,SAASC,2BAAkB,CAAC;EAC9D;AACF;AACA;AACA;EACSC,mBAAmBA,CAACL,IAAU,EAAW;IAC9C,OAAOM,OAAO,CACZN,IAAI,CAACC,MAAM,IACTD,IAAI,CAACC,MAAM,CAACM,iBAAiB,CAAC,gDAAgD,CAAC,IAC/EP,IAAI,CAACQ,MAAM,CAACC,KAAK,CAACX,mBAAmB,CACzC,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAaY,eAAeA,CAACV,IAAU,EAAE;IAAEW;EAA+B,CAAC,EAAiB;IAC1F,IAAI,CAAC,IAAI,CAACN,mBAAmB,CAACL,IAAI,CAAC,EAAE;IAErC,MAAMY,eAAe,GAAGb,mBAAmB,CAACC,IAAI,CAAC;;IAEjD;IACA;IACA;IACA,IAAIA,IAAI,CAACE,QAAQ,KAAKU,eAAe,EAAE;MACrCD,MAAM,CAAC,CAAC;IACV;EACF;;EAEA;EACA,MAAaE,uBAAuBA,CAAA,EAAkB;IACpD;EACF;AACF;AAACC,OAAA,CAAAjB,OAAA,GAAAM,eAAA","ignoreList":[]}